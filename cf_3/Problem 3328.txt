b'The BFS algorithm is defined as follows.'
b'  Consider an undirected graph with vertices numbered from 11 to nn. Initialize qq as a new queue containing only vertex 11, mark the vertex 11 as used.  Extract a vertex vv from the head of the queue qq.  Print the index of vertex vv.  Iterate in arbitrary order through all such vertices uu that uu is a neighbor of vv and is not marked yet as used. Mark the vertex uu as used and insert it into the tail of the queue qq.  If the queue is not empty, continue from step 2.  Otherwise finish. '
b'Since the order of choosing neighbors of each vertex can vary, it turns out that there may be multiple sequences which BFS can print.'
b'In this problem you need to check whether a given sequence corresponds to some valid BFS traversal of the given tree starting from vertex 11. The tree is an undirected graph, such that there is exactly one simple path between any two vertices.'
b'Input'
b'The first line contains a single integer nn (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x851051\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) which denotes the number of nodes in the tree. '
b'The following n\xe2\x88\x921n\xe2\x88\x921 lines describe the edges of the tree. Each of them contains two integers xx and yy (1\xe2\x89\xa4x,y\xe2\x89\xa4n1\xe2\x89\xa4x,y\xe2\x89\xa4n)\xc2\xa0\xe2\x80\x94 the endpoints of the corresponding edge of the tree. It is guaranteed that the given graph is a tree.'
b'The last line contains nn distinct integers a1,a2,\xe2\x80\xa6,ana1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4n1\xe2\x89\xa4ai\xe2\x89\xa4n)\xc2\xa0\xe2\x80\x94 the sequence to check.'
b'Output'
b'Print "Yes" (quotes for clarity) if the sequence corresponds to some valid BFS traversal of the given tree and "No" (quotes for clarity) otherwise.'
b'You can print each letter in any case (upper or lower).'
Tags
dfs and similar, graphs, shortest paths, trees, *1700
