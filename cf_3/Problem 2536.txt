b'You are given an array aa consisting of nn integers a1,a2,\xe2\x80\xa6,ana1,a2,\xe2\x80\xa6,an. You want to split it into exactly kk non-empty non-intersecting subsegments such that each subsegment has odd sum (i.\xe2\x80\x89e. for each subsegment, the sum of all elements that belong to this subsegment is odd). It is impossible to rearrange (shuffle) the elements of a given array. Each of the nn elements of the array aa must belong to exactly one of the kk subsegments.'
b"Let's see some examples of dividing the array of length 55 into 33 subsegments (not necessarily with odd sums): [1,2,3,4,5][1,2,3,4,5] is the initial array, then all possible ways to divide it into 33 non-empty non-intersecting subsegments are described below:"
b'  [1],[2],[3,4,5][1],[2],[3,4,5];  [1],[2,3],[4,5][1],[2,3],[4,5];  [1],[2,3,4],[5][1],[2,3,4],[5];  [1,2],[3],[4,5][1,2],[3],[4,5];  [1,2],[3,4],[5][1,2],[3,4],[5];  [1,2,3],[4],[5][1,2,3],[4],[5]. '
b'Of course, it can be impossible to divide the initial array into exactly kk subsegments in such a way that each of them will have odd sum of elements. In this case print "NO". Otherwise, print "YES" and any possible division of the array. See the output format for the detailed explanation.'
b'You have to answer qq independent queries.'
b'Input'
b'The first line contains one integer qq (1\xe2\x89\xa4q\xe2\x89\xa42\xe2\x8b\x851051\xe2\x89\xa4q\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of queries. Then qq queries follow.'
b'The first line of the query contains two integers nn and kk (1\xe2\x89\xa4k\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x851051\xe2\x89\xa4k\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of elements in the array and the number of subsegments, respectively.'
b'The second line of the query contains nn integers a1,a2,\xe2\x80\xa6,ana1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa41091\xe2\x89\xa4ai\xe2\x89\xa4109), where aiai is the ii-th element of aa.'
b'It is guaranteed that the sum of nn over all queries does not exceed 2\xe2\x8b\x851052\xe2\x8b\x85105 (\xe2\x88\x91n\xe2\x89\xa42\xe2\x8b\x85105\xe2\x88\x91n\xe2\x89\xa42\xe2\x8b\x85105).'
b'Output'
b'For each query, print the answer to it. If it is impossible to divide the initial array into exactly kk subsegments in such a way that each of them will have odd sum of elements, print "NO" in the first line. Otherwise, print "YES" in the first line and any possible division of the array in the second line. The division can be represented as kk integers r1r1, r2r2, ..., rkrk such that 1\xe2\x89\xa4r1<r2<\xe2\x8b\xaf<rk=n1\xe2\x89\xa4r1<r2<\xe2\x8b\xaf<rk=n, where rjrj is the right border of the jj-th segment (the index of the last element that belongs to the jj-th segment), so the array is divided into subsegments [1;r1],[r1+1;r2],[r2+1,r3],\xe2\x80\xa6,[rk\xe2\x88\x921+1,n][1;r1],[r1+1;r2],[r2+1,r3],\xe2\x80\xa6,[rk\xe2\x88\x921+1,n]. Note that rkrk is always nn but you should print it anyway. '
Tags
constructive algorithms, math, *1200
