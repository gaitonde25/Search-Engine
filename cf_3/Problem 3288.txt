b'There is an array aa of 230230 integers, indexed from 00 to 230\xe2\x88\x921230\xe2\x88\x921. Initially, you know that 0\xe2\x89\xa4ai<2300\xe2\x89\xa4ai<230 (0\xe2\x89\xa4i<2300\xe2\x89\xa4i<230), but you do not know any of the values. Your task is to process queries of two types:'
b' 1 l r x: You are informed that the bitwise xor of the subarray [l,r][l,r] (ends inclusive) is equal to xx. That is, al\xe2\x8a\x95al+1\xe2\x8a\x95\xe2\x80\xa6\xe2\x8a\x95ar\xe2\x88\x921\xe2\x8a\x95ar=xal\xe2\x8a\x95al+1\xe2\x8a\x95\xe2\x80\xa6\xe2\x8a\x95ar\xe2\x88\x921\xe2\x8a\x95ar=x, where \xe2\x8a\x95\xe2\x8a\x95 is the bitwise xor operator. In some cases, the received update contradicts past updates. In this case, you should ignore the contradicting update (the current update). 2 l r: You are asked to output the bitwise xor of the subarray [l,r][l,r] (ends inclusive). If it is still impossible to know this value, considering all past updates, then output \xe2\x88\x921\xe2\x88\x921.'
b'Note that the queries are encoded. That is, you need to write an online solution.'
b'Input'
b'The first line contains a single integer qq (1\xe2\x89\xa4q\xe2\x89\xa42\xe2\x8b\x851051\xe2\x89\xa4q\xe2\x89\xa42\xe2\x8b\x85105)\xc2\xa0\xe2\x80\x94 the number of queries.'
b'Each of the next qq lines describes a query. It contains one integer tt (1\xe2\x89\xa4t\xe2\x89\xa421\xe2\x89\xa4t\xe2\x89\xa42)\xc2\xa0\xe2\x80\x94 the type of query.'
b'The given queries will be encoded in the following way: let lastlast be the answer to the last query of the second type that you have answered (initially, last=0last=0). If the last answer was \xe2\x88\x921\xe2\x88\x921, set last=1last=1.'
b" If t=1t=1, three integers follow, l\xe2\x80\xb2l\xe2\x80\xb2, r\xe2\x80\xb2r\xe2\x80\xb2, and x\xe2\x80\xb2x\xe2\x80\xb2 (0\xe2\x89\xa4l\xe2\x80\xb2,r\xe2\x80\xb2,x\xe2\x80\xb2<2300\xe2\x89\xa4l\xe2\x80\xb2,r\xe2\x80\xb2,x\xe2\x80\xb2<230), meaning that you got an update. First, do the following: l=l\xe2\x80\xb2\xe2\x8a\x95lastl=l\xe2\x80\xb2\xe2\x8a\x95last, r=r\xe2\x80\xb2\xe2\x8a\x95lastr=r\xe2\x80\xb2\xe2\x8a\x95last, x=x\xe2\x80\xb2\xe2\x8a\x95lastx=x\xe2\x80\xb2\xe2\x8a\x95last and, if l>rl>r, swap ll and rr.This means you got an update that the bitwise xor of the subarray [l,r][l,r] is equal to xx (notice that you need to ignore updates that contradict previous updates). If t=2t=2, two integers follow, l\xe2\x80\xb2l\xe2\x80\xb2 and r\xe2\x80\xb2r\xe2\x80\xb2 (0\xe2\x89\xa4l\xe2\x80\xb2,r\xe2\x80\xb2<2300\xe2\x89\xa4l\xe2\x80\xb2,r\xe2\x80\xb2<230), meaning that you got a query. First, do the following: l=l\xe2\x80\xb2\xe2\x8a\x95lastl=l\xe2\x80\xb2\xe2\x8a\x95last, r=r\xe2\x80\xb2\xe2\x8a\x95lastr=r\xe2\x80\xb2\xe2\x8a\x95last and, if l>rl>r, swap ll and rr.For the given query, you need to print the bitwise xor of the subarray [l,r][l,r]. If it is impossible to know, print \xe2\x88\x921\xe2\x88\x921. Don't forget to change the value of lastlast."
b'It is guaranteed there will be at least one query of the second type.'
b'Output'
b'After every query of the second type, output the bitwise xor of the given subarray or \xe2\x88\x921\xe2\x88\x921 if it is still impossible to know.'
Tags
data structures, dsu, *2400
