b'Suppose you had an array AA of nn elements, each of which is 00 or 11.'
b'Let us define a function f(k,A)f(k,A) which returns another array BB, the result of sorting the first kk elements of AA in non-decreasing order. For example, f(4,[0,1,1,0,0,1,0])=[0,0,1,1,0,1,0]f(4,[0,1,1,0,0,1,0])=[0,0,1,1,0,1,0]. Note that the first 44 elements were sorted.'
b'Now consider the arrays B1,B2,\xe2\x80\xa6,BnB1,B2,\xe2\x80\xa6,Bn generated by f(1,A),f(2,A),\xe2\x80\xa6,f(n,A)f(1,A),f(2,A),\xe2\x80\xa6,f(n,A). Let CC be the array obtained by taking the element-wise sum of B1,B2,\xe2\x80\xa6,BnB1,B2,\xe2\x80\xa6,Bn.'
b'For example, let A=[0,1,0,1]A=[0,1,0,1]. Then we have B1=[0,1,0,1]B1=[0,1,0,1], B2=[0,1,0,1]B2=[0,1,0,1], B3=[0,0,1,1]B3=[0,0,1,1], B4=[0,0,1,1]B4=[0,0,1,1]. Then C=B1+B2+B3+B4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]C=B1+B2+B3+B4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4].'
b'You are given CC. Determine a binary array AA that would give CC when processed as above. It is guaranteed that an array AA exists for given CC in the input. '
b'Input'
b'The first line contains a single integer tt (1\xe2\x89\xa4t\xe2\x89\xa410001\xe2\x89\xa4t\xe2\x89\xa41000) \xc2\xa0\xe2\x80\x94 the number of test cases.'
b'Each test case has two lines. The first line contains a single integer nn (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x851051\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105).'
b'The second line contains nn integers c1,c2,\xe2\x80\xa6,cnc1,c2,\xe2\x80\xa6,cn (0\xe2\x89\xa4ci\xe2\x89\xa4n0\xe2\x89\xa4ci\xe2\x89\xa4n). It is guaranteed that a valid array AA exists for the given CC.'
b'The sum of nn over all test cases does not exceed 2\xe2\x8b\x851052\xe2\x8b\x85105.'
b'Output'
b'For each test case, output a single line containing nn integers a1,a2,\xe2\x80\xa6,ana1,a2,\xe2\x80\xa6,an (aiai is 00 or 11). If there are multiple answers, you may output any of them.'
Tags
constructive algorithms, data structures, greedy, implementation, math, two pointers, *1900
