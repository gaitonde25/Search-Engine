b'You are given an array aa consisting of nn non-negative integers. You have to choose a non-negative integer xx and form a new array bb of size nn according to the following rule: for all ii from 11 to nn, bi=ai\xe2\x8a\x95xbi=ai\xe2\x8a\x95x (\xe2\x8a\x95\xe2\x8a\x95 denotes the operation bitwise XOR).'
b'An inversion in the bb array is a pair of integers ii and jj such that 1\xe2\x89\xa4i<j\xe2\x89\xa4n1\xe2\x89\xa4i<j\xe2\x89\xa4n and bi>bjbi>bj.'
b'You should choose xx in such a way that the number of inversions in bb is minimized. If there are several options for xx \xe2\x80\x94 output the smallest one.'
b'Input'
b'First line contains a single integer nn (1\xe2\x89\xa4n\xe2\x89\xa43\xe2\x8b\x851051\xe2\x89\xa4n\xe2\x89\xa43\xe2\x8b\x85105) \xe2\x80\x94 the number of elements in aa.'
b'Second line contains nn space-separated integers a1a1, a2a2, ..., anan (0\xe2\x89\xa4ai\xe2\x89\xa41090\xe2\x89\xa4ai\xe2\x89\xa4109), where aiai is the ii-th element of aa.'
b'Output'
b'Output two integers: the minimum possible number of inversions in bb, and the minimum possible value of xx, which achieves those number of inversions.'
Tags
bitmasks, data structures, divide and conquer, dp, greedy, math, sortings, strings, trees, *2000
